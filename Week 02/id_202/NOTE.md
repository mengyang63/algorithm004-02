# NOTE
#### ############################################     week02         ############################################################
1、HashMap源码解析
    1.1 HashMap= 数组+链表  (<jdk1.8)   

​	1.2 HashMap= 数组+链表+红黑树(>=jdk1.8)

​	1.3 异同

​		相同的地方：

​			1、new HashMap时只创建了该对象，未对数组进行初始化；

​			2、put方法

​					进行了空判断：空的话进行初始化数组（默认大小为16，如果不是2^n，会强制转化成2^n）并将元素放入；

​					加载因子0.75（默认，时间与空间的平衡，牛顿二项式定理），如果size大于16*0.75则进行扩容

​			不同的地方：

​				1.7放入元素是如果是hash碰撞进行链表转换时，采用的时头插法（头尾指针双指针），扩容迁移的时候多线程并发会存在死循环问题（产生环），并且需要将所有迁移元素进行rehash。

​				1.8放入元素是采用尾插法，解决了扩容死循环问题，采用四指针法进行迁移，高位也进行位运算（这个就是需要数组的大小需要2^n次的原因）。

​				1.8在单链表的阈值超过8（泊松分布）时会对链表进化成红黑树，优化性能，同时，如果当这个红黑树的节点小于6时也会退化成链表									

​			
2、学习总结：
    1、树的概念以及二叉树一些用法
    2、遍历方式：前序遍历、中序遍历（升序）、后序遍历
    3、实现方式：递归、分治、回溯
    4、深度优先搜索：通常使用递归的方式
    5、广度优先搜索：通常结合队列使用

