# 位运算
- 位运算符
机器里数字的表现方式和存储的是二进制，使用位运算更快

|含义|运算符|示例|
|:---:|:---:|:---|
|左移| << |0011 => 0110|
|右移| \>> |0110 => 0011|
|按位或|\|0000 \ 1011 => 1011|
|按位与|&|0011 \ 1011 => 0011|
|按位取相反|~|0011 => 1100|
|按位异或|^|0011 \1011 => 1000|

将x最右边的n位清零: x&(~0<<n) => x&(1<<n)

判断奇偶性
x%2 == 1 -->  (x&1) == 1
x%2 == 0 -->  (x&1) == 0
- 算数移位与逻辑移位
- 位运算的应用

# 布隆过滤器 和 LAU Cache
HashTable + 拉链存储重复单元
Bloom Filter
一个很长的二进制向量和一些列随机映射函数。布隆过滤器可以用于检索一个元素是否存在集合中。
优点：
- 空间效率和查询时间都远远超过一般算法
缺点：
- 有一定的误识别率和删除困难

# LRU Cache 
- 两个要素：大小、替换策略
- HashTable + Double LinkedList
- O(1) 查询，O(1) 修改和更新
LRU - Least recently used
LFU - Least frequently used

# 初级排序 & 高级排序
- 比较类排序
  通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序
  交换排序：冒泡、快速
  插入排序：简单插入、希尔排序
  选择排序：简单选择、堆排序
  归并排序：二路归并排序、多路归并排序
- 非比较类排序
  可以基于比较排序的时间下界，以线性时间运行，因此也称线性时间非比较类排序
  计数排序、桶排序、基数排序

堆排序、快速排序、归并排序 O(nlogn)

- 初级排序 O(n^2)
  1. 选择排序 Selection Sort
  每次找最小值，然后放在待排序数组的起始位置
  2. 插入排序 Insertion Sort
  从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
  3. 冒泡排序 Bubble Sort
  嵌套循环，每次查看相邻元素如果逆序，则交换

- 高级排序 O(nlogn)
  1. 快速排序 Quick Sort
  数组取标杆 pivot , 将小于 pivot 的元素放在 pivot 左侧，大于的放右侧，然后依次对左右的子数组
  继续排序；以达到整个数组有序。
  2. 归并排序 Merge Sort - 分治
  a. 把长度为n的输入序列分成两个长度为n/2的子序列
  b. 对这两个子序列分别采用归并排序
  c. 将这两个排序好的子序列合并成一个最终的排序序列
  归并 和 快排 具有相似性，但步骤顺序相反
  归并：先排序左右子数组，然后合并两个有序子数组
  快排：先调配出左右子数组，然后对于左右子数组进行排序
  3. 堆排序 O(n*logn) Heap Sort 
  堆插入 O(logN); 取最大/最小值 O(1)
  a. 数组元素依次建立小顶堆
  b. 依次取堆顶元素，并删除

- 特殊排序 -O(n)
  1. 计数排序 Counting Sort
  计数排序要求输入的数组必须是具有确定范围的整数。将输入的数值转换为
  键存储在额外开辟的数组空间中；然后依次把大于1的填充回原数组
  2. 桶排序 Bucket Sort
  假设输入数据服从均匀分步，将数据分到有限数量的桶里，每个桶再分别排序
  （有可能再使用别的排序算法或是递归方式继续使用桶进行排序）
  3. 基数排序 Radix Sort
  按照低位先排序，然后收集；再按照高位排序，然后收集；依次类推，直到最高位。
  有时候有些属性是有优先级顺序的，先按低优先级顺序排序，再按高优先级排序
