# NOTE

## 第三周总结
本周开始学习深度优先DFS，广度优先BFS，此部分问题上周就有接触，上周反复练习递归法，迭代法解决树的遍历的问题，本周再通过深度优先和广度优先的练习，掌握的更加深刻，很多简单的题目基本都可以自己快速完成。  
再衍生的题型上还需提高，尤其本周的几个课堂练习和课后习题，后续需要继续努力提升。很多问题基本上转化为如何通过各种条件的判断和组合，最后转化为BFS，DFS的问题。  
贪心算法完成的还算可以，可能是因为已经事先知道题目可以用贪心算法完成，所以做起来目标比较明确。需要区分贪心算法与动态规划，一般贪心算法即为此问题的最优解，可以逐步往下，而动态规划略有不同，需要保存结果，以便返回寻找更优解。  
二分查找法，用了模版以后很多题目解答很快，但是需要更加注意边界条件，如left <= right, or left < right, mid = (left + right ) // 2 or mid = left + (right - left) // 2，或mid = (left + right + 1) // 2，很多时候边界条件没选好，导致死循环，此部分需要注意。  
解答二分查找法的问题时，还需要充分利用其有序性来解题。  
## 直播感想
关于直播最后，提出的如何做题，感触颇深。要牢记过遍数的思想，不会的问题千万不要死磕，模棱两可的问题直接看答案，抄一遍，理解深刻以后再写，不要死磕，不要死磕。  
看答案的过程中，一定要理解里面的思想，尤其看不同版本的答案，专注看对方如何分解问题为子问题，如何找到最小的重复单元，如何合理利用语言的特性。  
反复练习非常重要。  
## 代码作业
```

"""
使用二分查找，寻找一个半有序数组[4, 5, 6, 7, 0, 1, 2]中间无序的地方
"""
    def search(self, nums):
        if not nums: return -1
        if len(nums) == 1: return 0
        left = 0
        right = len(nums) - 1

        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > nums[mid + 1]:
                return mid + 1

            if nums[mid - 1] > nums[mid]:
                return mid

            if nums[mid] > nums[left]: # 左边有序
                left = mid + 1
            else:
                right = mid - 1
        return 0
```   

