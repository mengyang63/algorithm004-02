# NOTE
## 字典树 Trie
Trie以空间换时间，利用前缀公共节点，提高查询的效率。  
学习过程中，需要反复练习Trie的构建，以及查询。  
### 思考题
思考题： 分析单词搜索 2 用 Tire 树方式实现的时间复杂度，请同学们提交在第 6 周的学习总结中。  
单词遍历中，方法一复杂度计算：  
1. 遍历word, word数组长度为N，则为O(N)
2. borad数组为 m x n的数组，依次遍历，则为 O(m x n)
3. board中，每个元素有4种方向，假设word中单词的平均长度为K，有4^K次方或4 * 3 ^k-1
4. 最终复杂度O(N x m x n X 4^K)  

方法二、Trie复杂度分析
1. Build Dictionary, 遍历数组word, O（N），Trie的深度为K，构建复杂度为O(N x K)  
2. word数组长度为N, 平均单词长度为K，此方法查找时不需要遍历word了，用遍历Board的方式去字典匹配    
3. Board数组为 m x n的数组，遍历Board，复杂度为O(m x n)    
4. 遍历到的字母，则去查找在字典中是否存在，O(1)的复杂度  
5. 查找单词的话，需要对单词进行扩散，扩散K次（单词的长度，Trie的深度）  
6. 如果存在，则往四个通道扩散，复杂度为O(4)，并且查询扩散的结果是否在字典中，O(1)，所以复杂度为O(4)  
7. 则最终复杂度为 O(m x n x 4 ^ K) 或O(m x n x 4 x 3^K-1)  

## Disjoint Set 并查集
此问题时间不是特别充足，目前只做了一套题，后续还需要练习，主要是研究模版的原理。并查集的核心思想是往上找到共同的父节点，并且合并在一个集合里面。  
**模版需要熟练，目前原理还没弄清楚**

## 剪枝与双向BFS
剪枝与双向BFS都是对BFS的延伸，首先必须掌握BFS, DFS的两种写法：**递归，非递归**写法。  
如果不用剪枝算法，则需要在所有结果生成以后进行验证，效率低下。剪枝可以减少运算此事，爬楼梯问题，硬币兑换问题都是用剪枝的方法提高效率。  
双向BFS的方法核心是从两头扩散，但是此方法不是同时从两头扩散（个人理解，包括之前的误解），而是根据实际情况，决定从头开始扩散还是从尾部开始扩散，入word ladder问题。

### 思考题二，Two-ended BFS
```Python
def two_end_bfs(start, end, target):
    queue_left = []
    queue_left.append([start])
    queue_right = []
    queue_right.append([end])
    
    visited = { start }

    while queue_left and queue_right:
        if len(queue_left) > len(queue_right):
            queue_left, queue_right = queue_right, queue_left
        
        node = queue_left.pop()
        visited.add(node)
        
        process(node)
        nodes = generate_related_nodes(node)
        queue_left.push(nodes)
```
## 启发式搜索A*
参考数独解法的问题，数独解法是从头开始遍历，并且利用回溯剪枝递归的方法解决数独问题，但是如果启用A*方法，可以找到最好的估价函数，提前找到解决问题的方向，减少查询的次数。  
采用优先队列的方式来进行处理。  

## AVL与红黑树
引入AVL与红黑树的原因：**因为在二叉树的过程中，在极端情况下，树会退化成链表，则复杂度为O(n)，需要寻找新的树来提速，方法是保证左右的平衡**。  
**AVL树**：引入平衡因子，分别为{-1, 0, 1}，通过四种方式来进行选择，分别是左旋，右旋，左右旋，右左旋。  
操作过程中：需要记录每个节点的平衡因子，需要额外的空间，并且在插入的过程中需要反复的旋转，调整平衡因子，操作复杂。为了提高性能，需要减少旋转的次数，于是引入**红黑树**。  
**红黑树**：红黑树要求左右子树的高度差小于2倍，且要求：  
1. 每个结点要么是红色，要么是黑色  
2. 根节点是黑色  
3. 每个叶节点(NIL节点，空节点)是黑色的。  
4. 不能有相邻接的两个红色节点  
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。  
红黑树的节点存储可用位来表示，节约空间。  
上述两种树，由于AVL树的插入需要不断调整，代价较大，且为平衡二叉树，比较适合读。而红黑树由于插入时调整频率低，代价小，适合写。  
        


  

