# NOTE

```
硬核知识，如何掌握?
上周和本周的知识点，还是比较硬核的，无论是理解理论，还是实战做题，都遇到了不少的困难。
动态规划的状态定义，DP方程的设计，都是需要技巧、经验、刻意练习，DP方程的推导，Induction，找到一点儿感觉：用数学归纳法的思想去理解，能够更加具象。
本周的知识点，较上周而言更零散，但都是核心的数据结构和算法思想，在看完视频并做课后练习之后，觉得：一个好的数据结构可以有效解决问题，显著降低时间复杂度。
单词搜索II习题中，个人还是对递归的第四步[revert state]，掌握的不够清楚，不知道何种情况下需要revert回溯。
高级搜索模块，更是从实际业务的角度出发，更贴近实际应用场景，落地性更强。
AVL和红黑树章节，其中红黑树更是大名鼎鼎，工业级的数据结构及算法实现，JDK的代码中就有用到。
```

## Trie树 
- 理论知识不复杂
- 使用场景较为特殊，典型应用场景：词频统计、搜索提示
- 注意其扩展性，练习题中都是以小写26个字母作为可选项，实际生产应用中肯定会不止于此。

## 并查集
- [Algorithms 4th Edition](https://algs4.cs.princeton.edu/home/) Union-Find
- 实现很精简，带有权重，并且路径压缩，经过测试效率提升明显
- 使用场景包含：岛屿问题、朋友圈，注意在朋友圈问题中，与好友关系的数据结构：邻接矩阵、邻接表的关系，熟练掌握不同的数据结构解决不同的场景问题

## 高级搜索
- 剪枝
- 双向BFS
- 启发式搜索，Heuristic，A*搜索，欧氏距离、曼哈顿距离
- 以上技巧都是为了提升效率，更好的解决问题，否则效率低下，更甚者当前资源条件下无解，在生产应用中注意，更高效的方法有时候可以节省资源、BUG更少、处理更多规模问题
- 关于双向BFS，我觉得有其局限性：双向的目的是为了并行处理，提升速度，但是判断是否相交存在竞争条件，并发编程时特别注意。否则，你一下我一下，VS，你别动我来搞 两种模式差不多
- 高级搜索其实就是优先级搜索，不是傻搜，而是每次搜索时，带有挑选的规则判断，目的也是更优的达成目标。欧式距离的计算成本（平方、开方）大于曼哈顿距离的计算成本（加减、绝对值），所以曼哈顿距离实用性更高

## [单词搜索II](https://leetcode-cn.com/problems/word-search-ii/) 时间复杂度分析
- 假定board的总点数是N（如果N*N的话，个人觉得不如N整齐，有点儿唬人，其实目的都是为了表示board的规模，只不过board是一个二维数据，仅此而已，所以我用N来定义其规模）
- 假定word的平均长度为M
- board的每个点都可以作为起点，所以是N
- word的平均长度为M，Trie树的高度为M，所以检索word是否在树中是M
- 拼装每个word需要M步，每一步有4种选择，所以是4^M
- 所以整体时间复杂度为：N*M*4^M

